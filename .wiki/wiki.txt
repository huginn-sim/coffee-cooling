== Members/Roles ==
=== Cody Bomberger ===

=== Evin Özer ===
Created an initial model and visualized the results. In doing so, a well-documented template for future Python modules was developed.

== Discrete Model (Source Code) ==
=== Cody Bomberger ===

=== Evin Özer ===
The code is split into two modules: <code>coffee.py</code> and <code>coffee_plot.py</code>.

==== The <code>coffee</code> Module ====
The <code>coffee</code> module describes a model that approximates a cup of coffee's [[http://en.wikipedia.org/wiki/Convective_heat_transfer#Newton.27s_law_of_cooling|cooling rate]] as a function of time. To do so, two constants <code>cb</code> and <code>cc</code> are approximated using the [[http://wiki.cs.umt.edu/classes/cs477/index.php/Coffee_Cooling#Data|output]] of some discrete time model (<math>\Delta t=2</math> minutes). These constants represent the cooling properties specific to some vessel containing black or cream coffee. In good faith we assume that the vessel, coffee, cream, and their environment are similar to our model's assumptions. Subsequently, the constants are used to approximate the cooling rate of coffee at any time <math>t</math>; with known starting temperature <math>T_0</math> and room temperature <math>T_r</math>. 

At various intervals, cream is added to the modeled coffee; immediately lowering its temperature by 5&degree;C.

===== Source Code (coffee.py) =====

<syntaxhighlight lang="python">
# -*- coding: utf-8 -*-
##############################
#~ Coffee Cooling
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
#~ Team Hugenn
#~ 1/29/14
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
# coffee.py
# 1/31/14
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~#

#~ Modules
from coffee_plot import plot
from copy import copy
import  os, sys, atexit, \
        matplotlib.pyplot as plt, \
        numpy as np
#/~ Modules

#~ Setup
# Make sure the working directory is set to this script's location.
os.chdir(os.path.dirname(sys.argv[0]))
# Make sure any open plots are closed when this script ends.
atexit.register(lambda destruct: plt.close(), None)
#/~ Setup

#~ Globals
ideal_time = 1.2147
#/~

#~ Functions
def model(t0=0, tf=30, dt=.1, T0=90, Tf=70, Tp=75, Te=-5, experiments=3):
    """ Models the rate of cooling of coffee over time.

        :param t0: The inital time of Temperature measurement.
        :param tf: The maximum amount of time allotted for cooling.
        :param dt: The time differential.
        :param T0: The initial temperature of the object.
        :param Tf: The temperature equilibrium.
        :param Tp: The preferred temperature of the object.
        :param Te: The immediate change in temperature upon experiment.
        :param experiments: The number of intervals to conduct an experiment; add cream.
    """
    # Get 'indices' for cream experiments.
    offset = (ideal_time-t0) / (experiments+1); print offset
    indices = np.arange(t0+offset, ideal_time+(offset*5), offset)
    indices = [indices[1], indices[2], indices[-2], indices[-1]]
    indices = reversed(indices)
    # Initialize dictionaries with time steps.
    times = {}
    times['black'] = np.arange(t0,tf,dt)
    times['cream'] = times['black'][[int(i*(1/dt)) for i in indices]]

    return cool(times, t0, dt, T0, Tf, Tp, Te)

def cool(times, t0, dt, T0, Tf, Tp, Te):
    """  Calculates a set of Temperature values given some initial conditions and calculated constants.

        :param times: A dictionary of time measurements. ('black':interval, 'cream':samples of 'black')
        :param t0: The inital time of Temperature measurement.
        :param dt: The time differential.
        :param T0: The initial temperature of the object.
        :param Tf: The temperature equilibrium.
        :param Tp: The preferred temperature of the object.
        :param Te: The immediate change in temperature upon experiment.
    """
    # Defines a lambda function that calculates each new temperature.
    _cool = lambda current,final,constant,delta: (current - constant*(current - final)*delta)

    # Retrieve the 'sample data' and calculated thermal constants.
    data_times, (data_Temps_b, data_Temps_c), constants = sample_data()

    # Define 'super' lists to store the results of multiple experiments.
    super_times, super_Temps = [list(data_times), list(data_times)], [list(data_Temps_b), list(data_Temps_c)]
    # Define 'sub' lists to store the result of an experiment.
    sub_times, sub_Temps = [t0], [T0]
    
    just_right = False   # Not too hot; maybe a little cold.
    for tb in times['black']:   # For every time allotted for coffee cooling...
        # The current Temperature.
        Tc = sub_Temps[-1]
        # The cooling constant of black coffee.
        cb = constants['black'] 
        # The next Temperature according to the difference equation.
        Tn = _cool(Tc, Tf, cb, dt)

        # Log and save the the time/Temp when the coffee is "just right".
        if not just_right and Tp != None and (Tn+Te) <= Tp:
            just_right = True

            print "\n~ Add Cream ~"
            print "Preferred Temperature = "+str(Tp)+"°C"
            print "Current Temperature = "+str(Tn)+"°C"
            print "Current Time = " + str(tb) +" minutes\n"

            times['cream'] = np.concatenate(([tb], times['cream']))

        sub_times.append(tb)
        sub_Temps.append(Tn)

    super_times.append(sub_times)
    super_Temps.append(sub_Temps)

    for tc in times['cream']:   # For every chosen time to add cream to the coffee...
        # Find the index of 'tc' in times['black']. 
        index = int(np.where(times['black'] == tc)[0])

        # List of times starting from 'index'.         |    # Insert a duplicate time.
        sub_times = copy(super_times[2][index:]);      sub_times[1:1] = [sub_times[0]]
        # List of Temps starting from 'index'.         |    # Insert a duplicate Temp and add cream to T_i=1.
        sub_Temps = copy(super_Temps[2][index:]);      sub_Temps[1:1] = [sub_Temps[0]+Te]

        for i in range(2,len(sub_times)):   # Calculate the Temps of the creamed coffee...
            # The current Temperature.
            Tc = sub_Temps[i-1]
            # The cooling constant of cooled coffee.
            cc = constants['cream']
            # The next Temperature according to the difference euqation.
            Tn = _cool(Tc, Tf, cc, dt)

            sub_Temps[i] = Tn

        super_times.append(sub_times)
        super_Temps.append(sub_Temps)

    return super_times, super_Temps, constants

def sample_data(data=None):
    """ Calculates thermal constants from a dataset.
        
        :param data: The dataset used to derive cooling constants. If 'None' use default 'data'.
    """

    if data == None:    # Use default 'data' if none is provided by user.
        data = np.array([[  0. ,  82.3,  68.8], [  2. ,  78.5,  64.8],
                         [  4. ,  74.3,  62.1], [  6. ,  70.7,  59.9],
                         [  8. ,  67.6,  57.7], [ 10. ,  65. ,  55.9],
                         [ 12. ,  62.5,  53.9], [ 14. ,  60.1,  52.3],
                         [ 16. ,  58.1,  50.8], [ 18. ,  56.1,  49.5],
                         [ 20. ,  54.3,  48.1], [ 22. ,  52.8,  46.8],
                         [ 24. ,  51.2,  45.9], [ 26. ,  49.9,  44.8],
                         [ 28. ,  48.6,  43.7], [ 30. ,  47.2,  42.6],
                         [ 32. ,  46.1,  41.7], [ 34. ,  45. ,  40.8],
                         [ 36. ,  43.9,  39.9], [ 38. ,  43. ,  39.3],
                         [ 40. ,  41.9,  38.6], [ 42. ,  41. ,  37.7],
                         [ 44. ,  40.1,  37. ], [ 46. ,  39.5,  36.4]])

    times = data[:,0]
    Temps_black = data[:,1]
    Temps_cream = data[:,2]

    # Find the global min/max Temperatures.
    T_min = min(Temps_black[0], Temps_cream[0])
    T_max = max(Temps_black[-1], Temps_cream[-1])

    # The cooling constants of 'black' and 'cream' coffee.
    cb = 0.
    cc = 0.
    for i in range(len(times)-1): # Iterate through every sample vector in the dataset.
        # Calculate delta time. (In case non-uniform)
        dt = times[i+1] - times[i]

        # Calculate thermal constants at each moment, for both cases.
        cb += (Temps_black[i+1] - Temps_black[i]) / ((Temps_black[i] - Tf)*dt)
        cc += (Temps_cream[i+1] - Temps_cream[i]) / ((Temps_cream[i] - Tf)*dt)

    # Average the cooling constants.
    cb /= (len(times)-1); print "Black Coffee (c):\t" + str(cb)
    cc /= (len(times)-1); print "Cream Coffee (c):\t" + str(cc)

    return times, (Temps_black, Temps_cream), {'black': cb, 'cream': cc}

#~ Entry point of the script.
if __name__ == "__main__":
    t0 = 0
    tf = 40
    dt = 0.0001
    T0 = 90
    Tf = 20
    Tp = 75

    times, Temps, constants = model(t0, tf, dt, T0, Tf, Tp)
    
    dec = lambda x: len(str(x/10.).split('.')[0])

    t_max = round(times[0][-1], -dec(times[0][-1]))
    T_min = min(Temps[0][-1], Temps[1][-1])
    T_min = round(T_min, -dec(T_min)) - 10.*dec(T_min)
    T_max = max(Temps[0][0], Temps[1][0])
    T_max = round(T_max, -dec(T_max)) + 10.*dec(T_max)

    titles = ["Discrete Time Model: $\\Delta t="+str(dt)+"$ minutes; $\\epsilon\\propto\\Delta t$",
              "Sample Data: $\\Delta t=2$ minutes; $\\epsilon\\propto\\Delta t$"]

    plot(times, Temps,
        suptitle="Coffee Cooling",
        titles=titles,
        xlabels=["Time (minutes)"],
        ylabels=["Temperature ("+u'\N{DEGREE SIGN}'+"C)"],
        xbounds=[(t0,tf), (times[0][0],t_max)],
        ybounds=[(Tf,T0), (T_min,T_max)],
        legends=[{
            "Black Coffee":None,
            "Cream Coffee":None,
            "Cream Added":None,
            "$t^*="+str(times[3][0])+"$ minutes":None
        },
        {
            "Black Coffee: $\\bar{c_{\\mathbb{B}}}="+str(constants['black'])+"$":None, # What are the units of 'c_B'?
            "Cream Coffee: $\\bar{c_{\\mathbb{C}}}="+str(constants['cream'])+"$":None
        }])
</syntaxhighlight>

==== The <code>coffee_plot</code> Module ====
The <code>coffee_plot</code> module visualizes the output of the <code>coffee</code> module. It contains two functions: <code>configure_plot</code> and <code>plot</code>. The first function applies titles, labels, ticks, and adjustments to every subplot.

===== Source Code (coffee_plot.py) =====

<syntaxhighlight lang="python">
# -*- coding: utf-8 -*-
##############################
#~ Coffee Cooling
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
#~ Team Hugenn
#~ 1/30/14
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
# coffee_plot.py
# 1/31/14
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~#

#~ Modules
import  os, sys, atexit, \
        matplotlib.pyplot as plt, \
        numpy as np
#/~ Modules

#~ Functions
def configure_plot(ax, title, xlabel, ylabel, xbounds, ybounds):
    """ Configures the plot with the specified parameters.


    """
    # Set title, gridlines, and labels.
    ax.set_title(title, size=20)
    ax.grid(True, "major", alpha=.6)
    ax.grid(True, "minor", alpha=.4)
    ax.set_xlabel(xlabel)
    ax.set_ylabel(ylabel)

    # Hide spines.
    ax.spines['right'].set_visible(False)
    ax.spines['top'].set_visible(False)
    ax.spines['left'].set_visible(False)
    ax.spines['bottom'].set_visible(False)

    # Set the limits of the x,y axes.
    if xbounds == None:
        xbounds = ax.get_xlim()
    if ybounds == None:
        ybounds = ax.get_ylim()

    x_offset = abs(xbounds[1] - xbounds[0])/50.
    y_offset = abs(ybounds[1] - ybounds[0])/50.
    ax.set_xlim((xbounds[0] - x_offset, xbounds[1] + x_offset))
    ax.set_ylim((ybounds[0] - y_offset, ybounds[1] + y_offset))

    # X - Position and set major/minor ticks.
    ax.xaxis.set_ticks_position('bottom')
    offset = ax.get_xticks()[1] - ax.get_xticks()[0]
    ax.set_xticks(np.arange(ax.get_xticks()[1]+offset/2., ax.get_xticks()[-2], offset), minor=True)
    ax.xaxis.set_tick_params(width=4, length=5, color='k')
    ax.xaxis.set_tick_params(which="minor", width=2, length=4, color='k')
    
    # Y - Position and set major/minor ticks.
    ax.yaxis.set_ticks_position('left')
    offset = ax.get_yticks()[1] - ax.get_yticks()[0]
    ax.set_yticks(np.arange(ax.get_yticks()[1] + offset/2., ax.get_yticks()[-2], offset), minor=True)
    ax.yaxis.set_tick_params(width=4, length=5, color='k')
    ax.yaxis.set_tick_params(which="minor", width=2, length=4, color='k')

    # Draw x,y axes.
    x_edge = (xbounds[1] - xbounds[0]) / ((xbounds[1] - xbounds[0]) + x_offset)
    y_edge = (ybounds[1] - ybounds[0]) / ((ybounds[1] - ybounds[0]) + y_offset)
    ax.axhline(ybounds[0] - y_offset, 1-x_edge, x_edge, lw=4, color="k", alpha=1.)
    ax.axvline(xbounds[0] - x_offset, 1-y_edge, y_edge, lw=4, color="k", alpha=1.)

def plot(times, Temps, suptitle=None, titles=None, xlabels=None, ylabels=None, xbounds=None, ybounds=None, legends=None):
    """ TODO """    
    # Initially, assume that no legend will be generated.
    legendary = False
    if type(titles) == list and type(xlabels) == list and type(ylabels) == list and type(xbounds) == list and type(ybounds) == list:
        if len(titles) == 1:
            titles = [titles[0], titles[0]]
        if len(xlabels) == 1:
            xlabels = [xlabels[0], xlabels[0]]
        if len(ylabels) == 1:
            ylabels = [ylabels[0], ylabels[0]]
        if len(xbounds) == 1:
            xbounds = [xbounds[0], xbounds[0]]
        if len(ybounds) == 1:
            ybounds = [ybounds[0], ybounds[0]]
        if type(legends) == list and len(legends) == 1:
            legends = [legends[0], legends[0]]

        fig, axes = plt.subplots(nrows=2, ncols=1, squeeze=True)
    elif type(titles) == str and type(xlabels) == str and type(ylabels) == str and type(xbounds) == tuple and type(ybounds) == tuple:
        titles = [titles]
        xlabels = [xlabel]; ylabels = [ylabels];
        xbounds = [xbounds]
        fig, ax = plt.subplots()
        axes = [ax, None]
    else:
        print "Invalid configuration. Read docstring for more information."
        return

    if legends != None:
        black, cream, added = "Black Coffee", "Cream Coffee", "Cream Added"
        best = "$t^*="+str(times[3][0])+"$ minutes"
        legend = legends[0]

        legendary = True
    
    analysis_ax, data_ax = axes[0], axes[1]
    #~ Cream Coffee (at various times)
    for i,(time,Temp) in enumerate(zip(times,Temps)[4:-1]):
        #cream_mark0, = analysis_ax.plot(times[3], Temps[3], 'w-', lw=3.5)
        #cream_mark1, = analysis_ax.plot(time, Temp, c='k', ls='-', lw=3, alpha=1)
        cream_mark0, = analysis_ax.plot(time, Temp, c='w', ls='-', lw=2.5)
        cream_mark1, = analysis_ax.plot(time, Temp, c='#C48B52', ls='-', lw=2, alpha=.5)

        if legendary and i == 0:
            legend[cream] = (cream_mark0,cream_mark1)#,cream_mark2,cream_mark3)

    #best_mark0, = analysis_ax.plot(times[3], Temps[3], c='b', ls='-', lw=2)#, alpha=.5)
    best_mark1, = analysis_ax.plot(times[3], Temps[3], 'w-', lw=6)
    #best_mark2, = analysis_ax.plot(times[3], Temps[3], 'b-', lw=3)
    best_mark2, = analysis_ax.plot(times[3], Temps[3], c='#C48B52', ls='-', lw=3)

    #~ Black Coffee (no cream)
    black_mark0, = analysis_ax.plot(times[2], Temps[2], 'k-', lw=6)
    black_mark1, = analysis_ax.plot(times[2], Temps[2], c='#5A352D', ls='-', lw=5)
    
    if legendary:
        legend[black] = (black_mark0,black_mark1)

    #~ Cream Coffee (points of cream addition)
    for i,(time,Temp) in enumerate(zip(times,Temps)[4:-1]):
        cream_point_mark0, = analysis_ax.plot(time[0], Temp[0], 'ko', ms=10)
        cream_point_mark1, = analysis_ax.plot(time[0], Temp[0], c='#C48B52', marker='o', ms=8)
        
        if legendary and i == 0:
            legend[added] = (cream_point_mark0,cream_point_mark1)

    #~ Best Mark (Contd.)
    best_mark4, = analysis_ax.plot(times[3][0], Temps[3][0], 'w*', ms=30)
    best_mark5, = analysis_ax.plot(times[3][0], Temps[3][0], c='#C48B52', marker='*', ms=16)
    
    if legendary:
        legend[best] = (best_mark1,best_mark2,best_mark4,best_mark5)

    fig.suptitle(suptitle, size=30)
    
    analysis_ax.set_axisbelow(True)
    configure_plot(ax=analysis_ax,
                   title=titles[0],
                   xlabel=xlabels[0],
                   ylabel=ylabels[0],
                   xbounds=(0, 3),#xbounds[0]
                   ybounds=(70, 90))#ybounds[0])

    analysis_ax.legend([legend[black], legend[cream], legend[added], legend[best]],
               [black, cream, added, best],
               numpoints=1)

    if data_ax != None:
        plt.sca(data_ax)
        
        legendary = False
        if legends != None and legends[1] != None:
            legend = legends[1]
            legendary = True
        
        #~ Black Coffee (no cream)
        black_mark0, = data_ax.plot(times[0], Temps[0], 'k', lw=6)
        black_mark1, = data_ax.plot(times[0], Temps[0], c='#5A352D', marker='o', ms=10, ls='-', lw=5)
        cream_mark0, = data_ax.plot(times[1], Temps[1], 'k', lw=6)
        cream_mark1, = data_ax.plot(times[1], Temps[1], c='#C48B52', marker='o', ms=10, ls='-', lw=5)

        data_ax.set_axisbelow(True)
        configure_plot(ax=data_ax,
                       title=titles[1],
                       xlabel=xlabels[1],
                       ylabel=ylabels[1],
                       xbounds=xbounds[1],
                       ybounds=ybounds[1])
        
        #data_ax.set_yscale("log")
        
        if legendary:
            data_ax.legend([(black_mark0, black_mark1), (cream_mark0, cream_mark1)], sorted(legend.keys()), numpoints=1)

    fig.set_dpi(95)
    plt.subplots_adjust(left=0.05, right=0.95, top=0.9, bottom=0.05)
    plt.show()

#/~ Functions
</syntaxhighlight>

== Mathematical Basis ==

== Results ==
